## ДИСКЛЕЙМЕР: Я имею лишь поверхностные представления о внутреннем устройстве фреймворков. Последующий текст является результатом изысканий моего больного разума за последний день, а представленный в примерах код это абоминация из псевдо-кода и js.

# Часть 1: База

> Какие части приложения с какими могут общаться? Кто обновляет данные? Как при изменении части данных, фреймворк найдет какую часть перерендерить?
>

Перед ответом на эти насущные вопросы, необходимо для начала дать определение атомарной единице нашего приложения - компоненту.

Предположим, что у нас есть готовый рендерер. Нам неважно, каким образом он реализован, это может быть хоть обычная вставка через `innerHTML`, тогда

> Компонент - это некий объект, который может содержать в себе логику, обрабатывать набор входных параметров и, с помощью встроенного метода, вызывать рендерер для отрисовки своего состояния в DOM.
>

Исходя из этого определения, мы можем ответить на первый вопрос - внутри приложения будут существовать логический слой (состояние компонента, глобальное состояние) и слой UI (рендерер), которые общаются в рамках компонентов.

Для ответа на второй вопрос, выделим потенциальные источники изменяемых данных (инициаторы изменений) для компонента:

1. Параметры (аргументы) компонента (то есть инициатором будет вышестоящий компонент)
2. Внешнее (глобальное) хранилище
3. Сам компонент (обработка пользовательского ввода/внешнего запроса)

Третий вопрос. Чтобы работать с изменяемыми данными, воспользуемся принципом реактивности. Нам необходимо реализовать функцию подписки, которая сохранит связь “данные - эффект”. Тогда, при записи нового значения мы можем получить “эффекты”, которые надо выполнить после изменения данных. В качестве “эффекта” будет вызов зависимой функции (для компонентов мы можем вызывать встроенный метод рендера с новым состоянием).

Простейшая реализация будет выглядеть как-то так:

```jsx
// framework.js
effects = new WeakMap();

export subscribe(target, effect) { 
    if (effects.has(target)) {
        targetEffects = effects.get(target)
        targetEffects.add(effect)
    } else {
        targetEffects = new Set();
        targetEffects.add(effect);
        effects.set(target, targetEffects);
    }
}

export reactive(value) {
    obj = {
        get value() {
            return value;
        }
        
        set value(newValue) {
            value = newValue;
            if (effects.has(obj)) {
                effects.get(obj).forEach(effect => effect());   
            }
        }
    }
    
    return obj;
}

// component.js
class Component {
	init() {
	    this.reactiveObj = reactive('world');
	    
	    callback = this.render.bind(this);
	    subscribe(this.reactiveObj, callback);
	}
	
	update() {
	    this.reactiveObj.value = 'hello';
	}
	
	render() {
	    document.body.innerHTML = `Hello ${this.reactiveObj.value}`
	}
}
```

Подписку на параметры мы можем оформить во время создания компонента, спрятав это за синтаксическим сахаром или встроенным методом.

Таким образом, мы можем перерисовывать только компоненты, которые зависимы от измененных данных.

Можно также сделать проверку в рендере, какие именно данные изменились, закэшировав их состояние и сделав поверхностное сравнение новых данных с кэшем.

# Часть 2: Большая маленькая логика

> Как ты будешь помогать разбивать сложную бизнес-логику на строительные блоки, которые можно переносить из проекта в проект? Например, у нас есть поисковая строка и результаты поиска. По мере ввода нужно с одним debounce делать запросы на сервер, отдельно обрабатывать кеширование этих запросов, отдельно — обработку ошибок, с другим debounce — отправлять аналитику в Google Analytics. Или, например, сделать универсальный роутер или логику хранения данных в localStorage.
>

Благодаря компонентной структуре приложения, а также разделению рендера и логики компонентов, мы можем раздробить бизнес-логику на набор функций и UI-компонентов, которые затем можно переиспользовать внутри компонентов-оркестраторов (которые, в свою очередь, тоже можно переиспользовать).

Предположим, что у нас уже есть рендерер, который умеет парсить созданные компоненты и создавать виртуальное DOM-дерево.

Тогда, на примере с поисковой строкой и дебаунсерами мы можем сделать условно что-то такое:

```jsx
import Base, { reactive } from 'framework';
import template from 'framework/render';
import { SearchInput, List } from 'components/ui';
import { debounce } from 'utils';
import { getSearchResults, sendAnalytics } from 'api';
import { getCache, setCache } from 'cache';

export class SearchLogic extends Base {
    init() {
        // Imagine reactive already does subscription logic inside.
        this.searchResults = reactive([]);
    }
    
    processInput(value) {
        let results = getCache(value);
        if (!results) {
            results = debounce(getSearchResults(value));
            setCache(results);
        }
        debounce(sendAnalytics(value, results));
        this.searchResults.value = results;
    }
    
    render() {
        return template`<div>
            <SearchInput onInput={{this.processInput.bind(this)}} />
            <List values={{this.searchResults.value}} />
            </div>`;
    }
}
```

В примере сверху мы вынесли отдельно UI поискового инпута и списка поисковых результатов, а также выделили функции для работы с api, кэшем и утилиту дебаунсера для последующих переиспользований.

# Часть 3: Going offline

> Как ты организуешь архитектуру работы с сервером (не протоколы связи, а именно организация приложения), если требуется автообновление данных, работа в оффлайне, автоматическое исправление конфликтов редактирования за время оффлайна.
>

Чтобы веб-приложение работало оффлайн, мы можем пойти по пути local-first. Главным источником данных в таком случае становится не сервер, а браузер клиента. Сервер, же в свою очередь будет выступать в роли синхронизатора состояний между разными клиентами.

Для хранения состояния между сессиями будем использовать встроенное в браузер хранилище (а именно IndexedDB).

Автоматическое исправление конфликтов можно сделать с помощью добавления поля под временную метку внутри состояния. Метка должна будет меняться каждый раз, когда состояние обновляется. Тогда, во время следующей синхронизации состояний, конфликт можно будет разрешить, оставив последнюю версию состояния в качестве итоговой.

```jsx
// Предположим, у нас в хранилище такая запись

{
	// ...otherState
	todos: [{ name: 'Hello world', done: false, lastEdit: '2024-10-28T23:03:14.847Z', id: 'r21asd29:S' }]
}

// Тогда, если от сервера придет 

{
	todos: [{ name: 'Hello hello', done: false, lastEdit: '2024-10-28T23:03:20.847Z', id: 'r21asd29:S'}]
}

// То в ходе решения конфликта мы оставим последний вариант, т.е. вариант сервера.
```

Если мы хотим дать возможность пользователю самостоятельно выбирать между временными метками (а также в принципе переходить по истории изменений), то помимо самого состояния приложения, необходимо хранить лог операций над ним. В таком случае синхронизация будет происходить посредством обмена логами между клиентами, а новое состояние будет высчитываться на основе общего, смерженного лога.

```jsx
// Предположим наше состояние выглядит так

{
	todos: [{ name: 'Hello world', done: false, id: 'r21asd29:S' }]
}

// А лог вот так

[{ action: 'todo/change_name', value: 'Hello world', time: '2024-10-28T23:03:14.847Z', user: '11111111' }]

// Состояние второго клиента выглядит так

{
	todos: [{ name: 'Hello hello', done: true, id: 'r21asd29:S' }]
}

// А его лог следующий

[{ action: 'todo/change_status', value: true, time: '2024-10-28T23:03:20.847Z', user: '22222222' }]

// Тогда общее состояние после синхронизации будет таким

{
	todos: [{ name: 'Hello world', done: true, id: 'r21asd29:S' }]
}

// А лог будет таким

[
	{ action: 'todo/change_status', value: true, time: '2024-10-28T23:03:20.847Z', user: '22222222' },
	{ action: 'todo/change_name', value: 'Hello world', time: '2024-10-28T23:03:14.847Z', user: '11111111' }
]
```